<html>
<head>
<title>MessageNode</title>
</head>
<body>

<CENTER>
  <FONT SIZE=5> <B> EventMonitor </B> </FONT>
</CENTER>

<p>
EventMonitor monitors incoming JMS events and keeps tracking their states
according to the rulesets and the content of the aggregated events.
In case that the state changes up to a certain point, EventMonitor will
generate a new JMS event as the escalation.  All escalation events will
be routed to the done outLink.  For all the incoming events, EventMonitor
routes them into three outlinks: bypass for all the processed incoming
events, nohit for those events do not belong to any rulesets, failure for
the incoming events failed in the process.
</p>
<img vspace=10 halign=center src="EventMonitor.jpg" />
<p>
EventMonitor contains a number of predefined rulesets.  These rulesets
categorize incoming events into non-overlapping groups.  Therefore, each
ruleset defines a unique event group.  It contains the name of the rule,
and an EventSelector to select events for the group.  If PreferredOutLink
is defined in the ruleset, it is treated as a bypass ruleset. Otherwise,
it will be treated as an escalation ruleset that may generate extra messages.
</p>
<p>
For each incomiong event, EventMonitor will match it against every
EventSelectors to single out a ruleset. There are two cases for escalation
rulesets. If ClassName is defined in a ruleset, it will be used to
instantiate an instance of EventEscalation. Otherwise, it is the timeout
escalation ruleset in which EventMonitor expects certain events showing up
frequently. If a ruleset of EventEscalation is selected, EventMonitor will
invoke its public method of escalate() to evalaute the event. The instance
of EventEscalation is supposed to maintain the state for the event group.
In case that a state change is up to certain point, an escalation event will
be generated by its method of escalate(). This event will contain details
of the state change. It will be delivered according to the predefined
EscalationOrder with the value of either "first", "last" or "none" for no
order preference. In case of "first" or "last", the ruleset also allows
ActionDelay defined in millisec. In case of the ruleset of "last", it
specifies how long the escalation gets delayed. For the ruleset of "first",
the delay happens after the escalation. EscalationMask controls the display
mask on escalation messages.
</p>
<p>
In case of a ruleset for timeout escalations, EventMonitor will cache the
properties of the incoming event for an new state or update the timestamp of
an existing state with the incoming event. The ruleset expects certain
events kept coming to keep it up to date. If the expected event has not
shown up within a given interval, an escalation event will be generated as
the escalation with the priority set to EscalationPriority. A list of
attribute names is specified in CopiedProperty. Those attributes will be
cached from the first incoming event to the escalation event. The tracking
session for an existing state can be terminated by an event whose priority
is same as the predefined ResetPriority of the ruleset. The timeout
escalation ruleset is good to track those alerts fired only once.
</p>
<p>
EventMonitor always creates one extra ruleset, nohit. The ruleset of nohit
is for those events not hitting any patterns. Its RULE_PEND field is used to
store the total number of cached states for all timeout rulesets.
Please remember that there is no one-to-one relationship between the
candidate events and the esacaltion events. The total number of escalation
events for a ruleset is stored into its RULE_PEND field.
</p>
<p>
You are free to choose any names for the four fixed outlinks.  But
EventMonitor always assumes the first outlink for done, the second for bypass,
the third for failure and the last for nohit.  Any two or more outlinks can
share the same outlink name.  It means these outlinks are sharing the same
output channel.
</p>
<p>
The escalation is executed via the pre-defined rulesets. Therefore,
the configuration of the rulesets is critical to the operations of
EventMonitor.  Here are complete properties of rulesets for the node of
EventMonitor.

<table border=1>
<tr>
<th> Property Name </th> <th>Data Type</th> <th> Requirement </th> <th> Description </th> <th> Examples </th>
</tr>
<tr>
<td> Name </td> <td> alphanumeric with no spaces </td> <td> mandatory </td> <td> name of the ruleset </td> <td> event </td>
</tr>
<tr>
<td> Type </td> <td> string </td> <td> mandatory </td> <td> type of the Escalation </td> <td> MessageTracker </td>
</tr>
<tr>
<td> ClassName </td> <td> string </td> <td> mandatory </td> <td> full class name of implementation for EventEscalation </td> <td> org.qbroker.node.EventTracker </td>
</tr>
<tr>
<td> TimeToLive </td> <td> integer </td> <td> mandatory </td> <td> timeout in sec for tracking sessions </td> <td> 900 </td>
</tr>
<tr>
<td> EscalationPattern </td> <td> list </td> <td> optional </td> <td> list of patterns to terminate the session </td> <td> see example </td>
</tr>
<tr>
<td> KeyTemplate </td> <td> string </td> <td> required for timeout ruleset </td> <td> template for the tracking key </td> <td> ##name## </td>
</tr>
<tr>
<td> ResetPriority </td> <td> String </td> <td> optional </td> <td> name of the pririty to reset the escalation state </td> <td> INFO </td>
</tr>
<tr>
<td> EscalationPriority </td> <td> string </td> <td> required for timeout ruleset </td> <td> name of the priority for escalated event </td> <td> CRIT </td>
</tr>
<tr>
<td> EscalationMask </td> <td> Integer </td> <td> optional </td> <td> DisplayMask for escalated event </td> <td> 6 </td>
</tr>
<tr>
<td> ActiveTime </td> <td> map </td> <td> optional </td> <td> active time windows </td> <td> see example </td>
</tr>
<tr>
<td> Tolerance </td> <td> integer </td> <td> optional </td> <td> to escalate WARNING on the first specific number of consecutive failures </td> <td> 2 (default: 0) </td>
</tr>
<tr>
<td> MaxRetry </td> <td> integer </td> <td> optional </td> <td> to escalate ERR up to specific number of times if failure persists  </td> <td> 2 (default: 0) </td>
</tr>
<tr>
<td> MaxPage </td> <td> integer </td> <td> optional </td> <td> to escalate CRIT up to specific number of times if failure persists </td> <td> 2 (default: 0) </td>
</tr>
<tr>
<td> QuietPeriod </td> <td> integer </td> <td> optional </td> <td> to keep quiet up to specific number of times if failure still persists </td> <td> 2 (default: 2) </td>
</tr>
<tr>
<td> Aggregation </td> <td> list </td> <td> optional </td> <td> list of aggregations </td> <td> see example </td>
</tr>
<tr>
<td> CopiedProperty </td> <td> list </td> <td> optional </td> <td> for copying over the properties from the event </td> <td> see example </td>
</tr>
<tr>
<td> PreferredOutLink </td> <td> alphanumeric with no spaces </td> <td> mandatory for bypass only </td> <td> name of the preferred outlink </td> <td> bypass </td>
</tr>
<tr>
<td> EventPattern </td> <td> list </td> <td> optional </td> <td> list of patterns to select events </td> <td> see example </td>
</tr>
<tr>
<td> XEventPattern </td> <td> list </td> <td> optional </td> <td> list of patterns to exclude events </td> <td> see example </td>
</tr>
<tr>
<td> StringProperty </td> <td> map </td> <td> optional </td> <td> for displaying or resetting properties on the events </td> <td> see example </td>
</tr>
<tr>
<td> DisplayMask </td> <td> integer </td> <td> optional </td> <td> mask for loggings </td> <td> 64 (default: -1) </td>
</tr>
</table>
where EventPattern selects the events based on their content.  Aggregation
lists all the aggregate operations on the events.  Here is an example of
Aggregation:
<pre>
{
    ...
    "Aggregation": [{
      "FieldName": "body",
      "Operation": "append",
      "DefaultValue": ""
    }],
    ...
}
</pre>
</p>

<p>
Currently, there are two implementations of EventEscalation, EventTracker and
EventEscalator.  Each implementation may have its own configuration parameters.
Here is an example of a ruleset for MessageTracker with Aggregation:
<pre>
{
  "Name": "dam_bmam_invalid_syslog",
  "ClassName": "org.qbroker.event.EventTracker",
  "Site": "IPE",
  "Type": "MessageTracker",
  "Category": "DAM",
  "Description": "validating archived file size from BMAM and notify BMAM support if it happens",
  "Tolerance": "0",
  "MaxRetry": "8",
  "MaxPage": "2",
  "QuietPeriod": "0",
  "MinTimeSpan": "1",
  "EventPattern": [{
    "type": "^syslog$",
    "priority": "^INFO$",
    "AssetID": "^\\d+$",
    "hostname": "^damworker4prod[1-5]$",
    "TaskName": "^VALIDATE_TRANSFORMED$",
    "Rule": "^GENERIC_FILE_VALIDATION_FAILURE$",
    "Group": "^FILE_TRANSFER_SERVER_TO_ARCHIVE$"
  }],
  "XEventPattern": [{
    "Rest": "TaskExecutionException"
  }],
  "TimeToLive": "10800",
  "KeyTemplate": "##name##_##AssetID##",
  "Aggregation": [{
    "FieldName": "eventCount",
    "Operation": "count",
    "DefaultValue": "1"
  },{
    "FieldName": "hostname",
    "Operation": "last",
    "DefaultValue": "unknown"
  },{
    "FieldName": "RequestID",
    "Operation": "first",
    "DefaultValue": ""
  },{
    "FieldName": "LogTime",
    "Operation": "first",
    "Default": ""
  },{
    "FieldName": "TaskName",
    "Operation": "first",
    "Default": "Unknown"
  },{
    "FieldName": "AssetID",
    "Operation": "last",
    "Default": "0"
  },{
    "FieldName": "Rule",
    "Operation": "last",
    "Default": ""
  },{
    "FieldName": "Group",
    "Operation": "last",
    "Default": ""
  },{
    "FieldName": "Level",
    "Operation": "last",
    "Default": ""
  },{
    "FieldName": "Desc",
    "Operation": "last",
    "Default": ""
  },{
    "FieldName": "Advice",
    "Operation": "last",
    "Default": ""
  },{
    "FieldName": "url",
    "Operation": "last",
    "Default": ""
  },{
    "FieldName": "bmam_url",
    "Operation": "last",
    "Default": ""
  },{
    "FieldName": "Rest",
    "Operation": "first",
    "Default": "yyy",
  }],
  "EscalationPattern": [{
    "eventCount": ["[1,)"]
  }],
  "CopiedProperty": [
    "type",
    "hostname",
    "RequestID",
    "LogTime",
    "TaskName",
    "AssetID",
    "Rule",
    "Group",
    "Level",
    "Desc",
    "Advice",
    "url",
    "bmam_url",
    "Rest"
  ],
  "ActiveTime": {
    "TimeWindow": [{
      "Interval": "00:00:00-24:00:00"
    }]
  }
}
</pre>
where this rule is of MessageTracker for all BMAM events from DAM.  As you can
see, it reacts to every BMAM alerts.
</p>

<p>
Here is an example of EventMonitor:

<pre>
{
  "Name": "node_monitor",
  "ClassName": "org.qbroker.node.EventMonitor",
  "Operation": "monitor",
  "Capacity": "1024",
  "LinkName": "action",
  "XAMode": "1",
  "DisplayMask": "6",
  "Debug": "1",
  "StringProperty": {
    "priority": "",
    "name": "",
    "hostname": "",
    "site": "",
    "category": ""
  },
  "Ruleset": [
    "ardendo_monitor",
    "lep_path",
    "dam_bmam_invalid_syslog",
    "dam_harris_syslog",
    "dam_zero_size_syslog",
    "asset_syslog",
    "dam_syslog"
  ],
  "OutLink": ["pub", "pub", "pub", "pub"]
}
</pre>
where all the rules are defined externally.
</p>

</body>
</html>
